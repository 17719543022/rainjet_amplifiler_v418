C51 COMPILER V9.60.0.0   SLAVE                                                             02/13/2025 15:44:11 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE SLAVE
OBJECT MODULE PLACED IN slave.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE slave.c OPTIMIZE(6,SPEED) DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          #pragma NOIV                    // Do not generate interrupt vectors
   2          //-----------------------------------------------------------------------------
   3          //   File:      slave.c
   4          //   Contents:  Hooks required to implement USB peripheral function.
   5          //              Code written for FX2 REVE 56-pin and above.
   6          //              This firmware is used to demonstrate FX2 Slave FIF
   7          //              operation.
   8          //   Copyright (c) 2003 Cypress Semiconductor All rights reserved
   9          //-----------------------------------------------------------------------------
  10          #include "fx2.h"
  11          #include "fx2regs.h"
  12          #include "fx2sdly.h"            // SYNCDELAY macro
  13          
  14          #define LED_ALL         (bmBIT0 | bmBIT1 | bmBIT2 | bmBIT3)
  15          
  16          extern BOOL GotSUD;             // Received setup data flag
  17          extern BOOL Sleep;
  18          extern BOOL Rwuen;
  19          extern BOOL Selfpwr;
  20          
  21          BYTE Configuration;             // Current configuration
  22          BYTE AlternateSetting;          // Alternate settings
  23          BOOL done_frm_fpga = 0;
  24          
  25          // EZUSB FX2 PORTA = slave fifo enable(s), when IFCFG[1:0]=11
  26          //sbit PA0 = IOA ^ 0;             // alt. func., INT0#
  27          //sbit PA1 = IOA ^ 1;             // alt. func., INT1#
  28          // sbit PA2 = IOA ^ 2;          // is SLOE
  29          //sbit PA3 = IOA ^ 3;             // alt. func., WU2
  30          // sbit PA4 = IOA ^ 4;          // is FIFOADR0
  31          // sbit PA5 = IOA ^ 5;          // is FIFOADR1
  32          // sbit PA6 = IOA ^ 6;          // is PKTEND
  33          // sbit PA7 = IOA ^ 7;          // is FLAGD
  34          
  35          // EZUSB FX2 PORTC i/o...       port NA for 56-pin FX2
  36          // sbit PC0 = IOC ^ 0;
  37          // sbit PC1 = IOC ^ 1;
  38          // sbit PC2 = IOC ^ 2;
  39          // sbit PC3 = IOC ^ 3;
  40          // sbit PC4 = IOC ^ 4;
  41          // sbit PC5 = IOC ^ 5;
  42          // sbit PC6 = IOC ^ 6;
  43          // sbit PC7 = IOC ^ 7;
  44          
  45          // EZUSB FX2 PORTB = FD[7:0], when IFCFG[1:0]=11
  46          // sbit PB0 = IOB ^ 0;
  47          // sbit PB1 = IOB ^ 1;
  48          // sbit PB2 = IOB ^ 2;
  49          // sbit PB3 = IOB ^ 3;
  50          // sbit PB4 = IOB ^ 4;
  51          // sbit PB5 = IOB ^ 5;
  52          // sbit PB6 = IOB ^ 6;
  53          // sbit PB7 = IOB ^ 7;
  54          
  55          // EZUSB FX2 PORTD = FD[15:8], when IFCFG[1:0]=11 and WORDWIDE=1
C51 COMPILER V9.60.0.0   SLAVE                                                             02/13/2025 15:44:11 PAGE 2   

  56          //sbit PD0 = IOD ^ 0;
  57          //sbit PD1 = IOD ^ 1;
  58          //sbit PD2 = IOD ^ 2;
  59          //sbit PD3 = IOD ^ 3;
  60          //sbit PD4 = IOD ^ 4;
  61          //sbit PD5 = IOD ^ 5;
  62          //sbit PD6 = IOD ^ 6;
  63          //sbit PD7 = IOD ^ 7;
  64          
  65          // EZUSB FX2 PORTE is not bit-addressable...
  66          
  67          //-----------------------------------------------------------------------------
  68          // Task Dispatcher hooks
  69          // The following hooks are called by the task dispatcher.
  70          //-----------------------------------------------------------------------------
  71          //void LED_Off (BYTE LED_Mask);
  72          //void LED_On (BYTE LED_Mask);
  73          
  74          //-----------------------------------------------------------------------------
  75          // Task Dispatcher hooks
  76          //   The following hooks are called by the task dispatcher.
  77          //-----------------------------------------------------------------------------
  78          void TD_Init( void )
  79          { // Called once at startup
  80   1      
  81   1        CPUCS = 0x12; // CLKSPD[1:0]=10, for 48MHz operation, output CLKOUT
  82   1      
  83   1        PINFLAGSAB = 0x08;      // FLAGA - EP2EF
  84   1        SYNCDELAY;
  85   1        PINFLAGSCD = 0x0F;      // FLAGC - EP8FF
  86   1        SYNCDELAY;
  87   1        PORTACFG |= 0x80;
  88   1        SYNCDELAY;
  89   1        IFCONFIG = 0x03; //Internal clock, 48 MHz, Slave FIFO interface
  90   1        SYNCDELAY;
  91   1      
  92   1        // IFCLKSRC=1   , FIFOs executes on internal clk source 
  93   1        // xMHz=1       , 48MHz operation
  94   1        // IFCLKOE=1    ,Drive IFCLK pin signal at 48MHz
  95   1        // IFCLKPOL=0   , Don't invert IFCLK pin signal from internal clk
  96   1        // ASYNC=0      , master samples synchronous
  97   1        // GSTATE=0     , Don't drive GPIF states out on PORTE[2:0], debug WF
  98   1        // IFCFG[1:0]=11, FX2 in slave FIFO mode
  99   1      
 100   1      
 101   1        // Registers which require a synchronization delay, see section 15.14
 102   1        // FIFORESET        FIFOPINPOLAR
 103   1        // INPKTEND         OUTPKTEND
 104   1        // EPxBCH:L         REVCTL
 105   1        // GPIFTCB3         GPIFTCB2
 106   1        // GPIFTCB1         GPIFTCB0
 107   1        // EPxFIFOPFH:L     EPxAUTOINLENH:L
 108   1        // EPxFIFOCFG       EPxGPIFFLGSEL
 109   1        // PINFLAGSxx       EPxFIFOIRQ
 110   1        // EPxFIFOIE        GPIFIRQ
 111   1        // GPIFIE           GPIFADRH:L
 112   1        // UDMACRCH:L       EPxGPIFTRIG
 113   1        // GPIFTRIG
 114   1        
 115   1        // Note: The pre-REVE EPxGPIFTCH/L register are affected, as well...
 116   1        //      ...these have been replaced by GPIFTC[B3:B0] registers
 117   1      
C51 COMPILER V9.60.0.0   SLAVE                                                             02/13/2025 15:44:11 PAGE 3   

 118   1        // EP4 and EP8 are not used in this implementation...
 119   1                         
 120   1        EP2CFG = 0xA2;                //out 512 bytes, 2x, bulk
 121   1        SYNCDELAY;                    
 122   1        EP4CFG = 0xA2;                //out 512 bytes, 2x, bulk
 123   1        SYNCDELAY;                     
 124   1        EP6CFG = 0xE2;                // in 512 bytes, 2x, bulk
 125   1        SYNCDELAY;              
 126   1        EP8CFG = 0xE2;                // in 512 bytes, 2x, bulk
 127   1        SYNCDELAY;   
 128   1      
 129   1        SYNCDELAY;
 130   1        FIFORESET = 0x80;             // activate NAK-ALL to avoid race conditions
 131   1        SYNCDELAY;                    // see TRM section 15.14
 132   1        FIFORESET = 0x02;             // reset, FIFO 2
 133   1        SYNCDELAY;                    // 
 134   1        FIFORESET = 0x04;             // reset, FIFO 4
 135   1        SYNCDELAY;                    // 
 136   1        FIFORESET = 0x06;             // reset, FIFO 6
 137   1        SYNCDELAY;                    // 
 138   1        FIFORESET = 0x08;             // reset, FIFO 8
 139   1        SYNCDELAY;                    // 
 140   1        FIFORESET = 0x00;             // deactivate NAK-ALL
 141   1      
 142   1      
 143   1        // handle the case where we were already in AUTO mode...
 144   1        // ...for example: back to back firmware downloads...
 145   1        SYNCDELAY;                    // 
 146   1        EP2FIFOCFG = 0x00;            // AUTOOUT=0, WORDWIDE=1
 147   1        
 148   1        // core needs to see AUTOOUT=0 to AUTOOUT=1 switch to arm endp's
 149   1        
 150   1        SYNCDELAY;                    // 
 151   1        EP2FIFOCFG = 0x11;            // AUTOOUT=1, WORDWIDE=1
 152   1        
 153   1        SYNCDELAY;                    // 
 154   1        EP6FIFOCFG = 0x0D;            // AUTOIN=1, ZEROLENIN=1, WORDWIDE=1
 155   1      
 156   1        SYNCDELAY;                    // 
 157   1        EP8FIFOCFG = 0x0D;            // AUTOIN=1, ZEROLENIN=1, WORDWIDE=1
 158   1      
 159   1        SYNCDELAY;
 160   1      
 161   1      
 162   1      //JTAG Enable and SYNC signals for ZTEX Spartan 6 module 1.1 (FGPA+FX2LP setup)
 163   1        OEA|=0x02; //Declare PA.1 as output
 164   1        SYNCDELAY;
 165   1        IOA|=0x02; //output 1 on PA.1
 166   1        SYNCDELAY;
 167   1      
 168   1        OEC|=0x01; //PC.0 as output (SYNC signal)
 169   1        SYNCDELAY;
 170   1        IOC|=0x00; //output 0 on PC.0...SYNC signal is LOW 
 171   1        SYNCDELAY;
 172   1        OEC&=0xFD; //PC.1 as input (Clock changing signal)
 173   1        SYNCDELAY;
 174   1        
 175   1      
 176   1        
 177   1      }
 178          
 179          void TD_Poll( void )
C51 COMPILER V9.60.0.0   SLAVE                                                             02/13/2025 15:44:11 PAGE 4   

 180          { // Called repeatedly while the device is idle
 181   1      
 182   1          if(!(IOC & 0x02))
 183   1          {
 184   2          done_frm_fpga = 1;
 185   2          }
 186   1          if ((done_frm_fpga) && (IOC & 0x02))
 187   1          {
 188   2            IFCONFIG = 0x03;  //external clock input, Slave FIFO interface
 189   2            SYNCDELAY;
 190   2          
 191   2            IOC|=0x01; //output 1 on PC.0...SYNC signal is HIGH 
 192   2            SYNCDELAY;
 193   2            done_frm_fpga = 0;
 194   2            
 195   2          }
 196   1      
 197   1      }
 198          
 199          BOOL TD_Suspend( void )          
 200          { // Called before the device goes into suspend mode
 201   1         return( TRUE );
 202   1      }
 203          
 204          BOOL TD_Resume( void )          
 205          { // Called after the device resumes
 206   1         return( TRUE );
 207   1      }
 208          
 209          //-----------------------------------------------------------------------------
 210          // Device Request hooks
 211          //   The following hooks are called by the end point 0 device request parser.
 212          //-----------------------------------------------------------------------------
 213          BOOL DR_GetDescriptor( void )
 214          {
 215   1         return( TRUE );
 216   1      }
 217          
 218          BOOL DR_SetConfiguration( void )   
 219          { // Called when a Set Configuration command is received
 220   1        
 221   1        if( EZUSB_HIGHSPEED( ) )
 222   1        { // ...FX2 in high speed mode
 223   2          EP6AUTOINLENH = 0x02;
 224   2          SYNCDELAY;
 225   2          EP8AUTOINLENH = 0x02;   // set core AUTO commit len = 512 bytes
 226   2          SYNCDELAY;
 227   2          EP6AUTOINLENL = 0x00;
 228   2          SYNCDELAY;
 229   2          EP8AUTOINLENL = 0x00;
 230   2        }
 231   1        else
 232   1        { // ...FX2 in full speed mode
 233   2          EP6AUTOINLENH = 0x00;
 234   2          SYNCDELAY;
 235   2          EP8AUTOINLENH = 0x00;   // set core AUTO commit len = 64 bytes
 236   2          SYNCDELAY;
 237   2          EP6AUTOINLENL = 0x40;
 238   2          SYNCDELAY;
 239   2          EP8AUTOINLENL = 0x40;
 240   2        }
 241   1            
C51 COMPILER V9.60.0.0   SLAVE                                                             02/13/2025 15:44:11 PAGE 5   

 242   1        Configuration = SETUPDAT[ 2 ];
 243   1        return( TRUE );        // Handled by user code
 244   1      }
 245          
 246          BOOL DR_GetConfiguration( void )   
 247          { // Called when a Get Configuration command is received
 248   1         EP0BUF[ 0 ] = Configuration;
 249   1         EP0BCH = 0;
 250   1         EP0BCL = 1;
 251   1         return(TRUE);          // Handled by user code
 252   1      }
 253          
 254          BOOL DR_SetInterface( void )       
 255          { // Called when a Set Interface command is received
 256   1         AlternateSetting = SETUPDAT[ 2 ];
 257   1         return( TRUE );        // Handled by user code
 258   1      }
 259          
 260          BOOL DR_GetInterface( void )       
 261          { // Called when a Set Interface command is received
 262   1         EP0BUF[ 0 ] = AlternateSetting;
 263   1         EP0BCH = 0;
 264   1         EP0BCL = 1;
 265   1         return( TRUE );        // Handled by user code
 266   1      }
 267          
 268          BOOL DR_GetStatus( void )
 269          {
 270   1         return( TRUE );
 271   1      }
 272          
 273          BOOL DR_ClearFeature( void )
 274          {
 275   1         return( TRUE );
 276   1      }
 277          
 278          BOOL DR_SetFeature( void )
 279          {
 280   1         return( TRUE );
 281   1      }
 282          
 283          BOOL DR_VendorCmnd( void )
 284          {
 285   1        return( TRUE );
 286   1      }
 287          
 288          //-----------------------------------------------------------------------------
 289          // USB Interrupt Handlers
 290          //   The following functions are called by the USB interrupt jump table.
 291          //-----------------------------------------------------------------------------
 292          
 293          // Setup Data Available Interrupt Handler
 294          void ISR_Sudav( void ) interrupt 0
 295          {
 296   1         GotSUD = TRUE;         // Set flag
 297   1         EZUSB_IRQ_CLEAR( );
 298   1         USBIRQ = bmSUDAV;      // Clear SUDAV IRQ
 299   1      }
 300          
 301          // Setup Token Interrupt Handler
 302          void ISR_Sutok( void ) interrupt 0
 303          {
C51 COMPILER V9.60.0.0   SLAVE                                                             02/13/2025 15:44:11 PAGE 6   

 304   1         EZUSB_IRQ_CLEAR( );
 305   1         USBIRQ = bmSUTOK;      // Clear SUTOK IRQ
 306   1      }
 307          
 308          void ISR_Sof( void ) interrupt 0
 309          {
 310   1         EZUSB_IRQ_CLEAR( );
 311   1         USBIRQ = bmSOF;        // Clear SOF IRQ
 312   1      }
 313          
 314          void ISR_Ures( void ) interrupt 0
 315          {
 316   1         if ( EZUSB_HIGHSPEED( ) )
 317   1         {
 318   2            pConfigDscr = pHighSpeedConfigDscr;
 319   2            pOtherConfigDscr = pFullSpeedConfigDscr;
 320   2         }
 321   1         else
 322   1         {
 323   2            pConfigDscr = pFullSpeedConfigDscr;
 324   2            pOtherConfigDscr = pHighSpeedConfigDscr;
 325   2         }
 326   1         
 327   1         EZUSB_IRQ_CLEAR( );
 328   1         USBIRQ = bmURES;       // Clear URES IRQ
 329   1      }
 330          
 331          void ISR_Susp( void ) interrupt 0
 332          {
 333   1         Sleep = TRUE;
 334   1         EZUSB_IRQ_CLEAR( );
 335   1         USBIRQ = bmSUSP;
 336   1      }
 337          
 338          void ISR_Highspeed( void ) interrupt 0
 339          {
 340   1         if ( EZUSB_HIGHSPEED( ) )
 341   1         {
 342   2            pConfigDscr = pHighSpeedConfigDscr;
 343   2            pOtherConfigDscr = pFullSpeedConfigDscr;
 344   2         }
 345   1         else
 346   1         {
 347   2            pConfigDscr = pFullSpeedConfigDscr;
 348   2            pOtherConfigDscr = pHighSpeedConfigDscr;
 349   2         }
 350   1      
 351   1         EZUSB_IRQ_CLEAR( );
 352   1         USBIRQ = bmHSGRANT;
 353   1      }
 354          void ISR_Ep0ack( void ) interrupt 0
 355          {
 356   1      }
 357          void ISR_Stub( void ) interrupt 0
 358          {
 359   1      }
 360          void ISR_Ep0in( void ) interrupt 0
 361          {
 362   1      }
 363          void ISR_Ep0out( void ) interrupt 0
 364          {
 365   1      }
C51 COMPILER V9.60.0.0   SLAVE                                                             02/13/2025 15:44:11 PAGE 7   

 366          void ISR_Ep1in( void ) interrupt 0
 367          {
 368   1      }
 369          void ISR_Ep1out( void ) interrupt 0
 370          {
 371   1      }
 372          void ISR_Ep2inout( void ) interrupt 0
 373          {
 374   1      }
 375          void ISR_Ep4inout( void ) interrupt 0
 376          {
 377   1      }
 378          void ISR_Ep6inout( void ) interrupt 0
 379          {
 380   1      }
 381          void ISR_Ep8inout( void ) interrupt 0
 382          {
 383   1      }
 384          void ISR_Ibn( void ) interrupt 0
 385          {
 386   1      }
 387          void ISR_Ep0pingnak( void ) interrupt 0
 388          {
 389   1      }
 390          void ISR_Ep1pingnak( void ) interrupt 0
 391          {
 392   1      }
 393          void ISR_Ep2pingnak( void ) interrupt 0
 394          {
 395   1      }
 396          void ISR_Ep4pingnak( void ) interrupt 0
 397          {
 398   1      }
 399          void ISR_Ep6pingnak( void ) interrupt 0
 400          {
 401   1      }
 402          void ISR_Ep8pingnak( void ) interrupt 0
 403          {
 404   1      }
 405          void ISR_Errorlimit( void ) interrupt 0
 406          {
 407   1      }
 408          void ISR_Ep2piderror( void ) interrupt 0
 409          {
 410   1      }
 411          void ISR_Ep4piderror( void ) interrupt 0
 412          {
 413   1      }
 414          void ISR_Ep6piderror( void ) interrupt 0
 415          {
 416   1      }
 417          void ISR_Ep8piderror( void ) interrupt 0
 418          {
 419   1      }
 420          void ISR_Ep2pflag( void ) interrupt 0
 421          {
 422   1      }
 423          void ISR_Ep4pflag( void ) interrupt 0
 424          {
 425   1      }
 426          void ISR_Ep6pflag( void ) interrupt 0
 427          {
C51 COMPILER V9.60.0.0   SLAVE                                                             02/13/2025 15:44:11 PAGE 8   

 428   1      }
 429          void ISR_Ep8pflag( void ) interrupt 0
 430          {
 431   1      }
 432          void ISR_Ep2eflag( void ) interrupt 0
 433          {
 434   1      }
 435          void ISR_Ep4eflag( void ) interrupt 0
 436          {
 437   1      }
 438          void ISR_Ep6eflag( void ) interrupt 0
 439          {
 440   1      }
 441          void ISR_Ep8eflag( void ) interrupt 0
 442          {
 443   1      }
 444          void ISR_Ep2fflag( void ) interrupt 0
 445          {
 446   1      }
 447          void ISR_Ep4fflag( void ) interrupt 0
 448          {
 449   1      }
 450          void ISR_Ep6fflag( void ) interrupt 0
 451          {
 452   1      }
 453          void ISR_Ep8fflag( void ) interrupt 0
 454          {
 455   1      }
 456          void ISR_GpifComplete( void ) interrupt 0
 457          {
 458   1      }
 459          void ISR_GpifWaveform( void ) interrupt 0
 460          {
 461   1      }
 462          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    575    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      2    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
